\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{class_a_x25_client}{A\+X25\+Client}} \\*Client for A\+X25 communication }{\pageref{class_a_x25_client}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_a_x25_frame}{A\+X25\+Frame}} \\*Abstraction of A\+X.\+25 frame format }{\pageref{class_a_x25_frame}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_c_c1101}{C\+C1101}} \\*Control class for C\+C1101 module }{\pageref{class_c_c1101}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_cluster_duck}{Cluster\+Duck}} \\*External A\+P\+Is to build and control a duck device }{\pageref{class_cluster_duck}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_duck}{Duck}} }{\pageref{class_duck}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_duck_detect}{Duck\+Detect}} }{\pageref{class_duck_detect}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_duck_display}{Duck\+Display}} \\*Internal O\+L\+ED Display abstraction }{\pageref{class_duck_display}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_duck_led}{Duck\+Led}} \\*Internal on board L\+ED abstraction }{\pageref{class_duck_led}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_duck_link}{Duck\+Link}} }{\pageref{class_duck_link}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_duck_lora}{Duck\+Lora}} \\*Internal Lo\+Ra chip abstraction }{\pageref{class_duck_lora}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_duck_net}{Duck\+Net}} \\*Internal network abstraction }{\pageref{class_duck_net}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_s_p8266}{E\+S\+P8266}} \\*Control class for E\+S\+P8266 module. Implements \mbox{\hyperlink{class_transport_layer}{Transport\+Layer}} methods }{\pageref{class_e_s_p8266}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_h_c05}{H\+C05}} \\*Control class for H\+C05 module. Most methods supported by this module are implemented in \mbox{\hyperlink{class_i_serial}{I\+Serial}} interface }{\pageref{class_h_c05}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_h_t_t_p_client}{H\+T\+T\+P\+Client}} \\*Client for simple H\+T\+TP communication }{\pageref{class_h_t_t_p_client}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_i_serial}{I\+Serial}} \\*Interface class for Arduino Serial. Only calls the appropriate methods for the active U\+A\+RT interface }{\pageref{class_i_serial}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_i_t_a2_string}{I\+T\+A2\+String}} \\*I\+T\+A2-\/encoded string }{\pageref{class_i_t_a2_string}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_j_d_y08}{J\+D\+Y08}} \\*Control class for J\+D\+Y08 module. Most methods supported by this module are implemented in \mbox{\hyperlink{class_i_serial}{I\+Serial}} interface }{\pageref{class_j_d_y08}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_lora_config_params}{Lora\+Config\+Params}} \\*Internal structure to hold the Lo\+Ra module configuration }{\pageref{struct_lora_config_params}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_mama_duck}{Mama\+Duck}} }{\pageref{class_mama_duck}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_module}{Module}} \\*Implements all common low-\/level S\+P\+I/\+U\+A\+R\+T/\+I2C methods to control the wireless module. Every module class contains one private instance of this class }{\pageref{class_module}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_morse_client}{Morse\+Client}} \\*Client for Morse Code communication. The public interface is the same as Arduino Serial }{\pageref{class_morse_client}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_m_q_t_t_client}{M\+Q\+T\+T\+Client}} \\*Client for simple M\+Q\+TT communication }{\pageref{class_m_q_t_t_client}}{}
\item\contentsline{section}{\mbox{\hyperlink{classn_r_f24}{n\+R\+F24}} \\*Control class for n\+R\+F24 module }{\pageref{classn_r_f24}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_packet}{Packet}} \\*Internal cluster duck Lo\+Ra message structure }{\pageref{struct_packet}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_papa_duck}{Papa\+Duck}} }{\pageref{class_papa_duck}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_physical_layer}{Physical\+Layer}} \\*Provides common interface for protocols that run on Lo\+Ra/\+F\+SK modules, such as R\+T\+TY or Lo\+Ra\+W\+AN. Also extracts some common module-\/independent methods. Using this interface class allows to use the protocols on various modules without much code duplicity. Because this class is used mainly as interface, all of its virtual members must be implemented in the module class }{\pageref{class_physical_layer}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_radio}{Radio}} \\*Library control object when using Radio\+Shield. Contains two pre-\/configured \char`\"{}modules\char`\"{}, which correspond to the slots on shield }{\pageref{class_radio}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_r_f69}{R\+F69}} \\*Control class for R\+F69 module. Also serves as base class for \mbox{\hyperlink{class_s_x1231}{S\+X1231}} }{\pageref{class_r_f69}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_r_f_m95}{R\+F\+M95}} \\*Derived class for R\+F\+M95 modules. Overrides some methods from \mbox{\hyperlink{class_s_x1278}{S\+X1278}} due to different parameter ranges }{\pageref{class_r_f_m95}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_r_f_m96}{R\+F\+M96}} \\*Derived class for R\+F\+M96 modules. Overrides some methods from \mbox{\hyperlink{class_s_x1278}{S\+X1278}} due to different parameter ranges }{\pageref{class_r_f_m96}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_r_f_m97}{R\+F\+M97}} \\*Derived class for R\+F\+M97 modules. Overrides some methods from \mbox{\hyperlink{class_r_f_m95}{R\+F\+M95}} due to different parameter ranges }{\pageref{class_r_f_m97}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_r_f_m98}{R\+F\+M98}} \\*Only exists as alias for \mbox{\hyperlink{class_r_f_m96}{R\+F\+M96}}, since there seems to be no difference between R\+F\+M96 and R\+F\+M98 modules }{\pageref{class_r_f_m98}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_r_t_t_y_client}{R\+T\+T\+Y\+Client}} \\*Client for R\+T\+TY communication. The public interface is the same as Arduino Serial }{\pageref{class_r_t_t_y_client}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_s_x1231}{S\+X1231}} \\*Control class for S\+X1231 module. Overrides some methods from \mbox{\hyperlink{class_r_f69}{R\+F69}} due to different register values }{\pageref{class_s_x1231}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_s_x1261}{S\+X1261}} \\*Derived class for S\+X1261 modules }{\pageref{class_s_x1261}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_s_x1262}{S\+X1262}} \\*Derived class for S\+X1262 modules }{\pageref{class_s_x1262}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_s_x1268}{S\+X1268}} \\*Derived class for S\+X1268 modules }{\pageref{class_s_x1268}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_s_x126x}{S\+X126x}} \\*Base class for S\+X126x series. All derived classes for S\+X126x (e.\+g. \mbox{\hyperlink{class_s_x1262}{S\+X1262}} or \mbox{\hyperlink{class_s_x1268}{S\+X1268}}) inherit from this base class. This class should not be instantiated directly from Arduino sketch, only from its derived classes }{\pageref{class_s_x126x}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_s_x1272}{S\+X1272}} \\*Derived class for S\+X1272 modules. Also used as base class for \mbox{\hyperlink{class_s_x1273}{S\+X1273}}. Both modules use the same basic hardware and only differ in parameter ranges }{\pageref{class_s_x1272}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_s_x1273}{S\+X1273}} \\*Derived class for S\+X1273 modules. Overrides some methods from \mbox{\hyperlink{class_s_x1272}{S\+X1272}} due to different parameter ranges }{\pageref{class_s_x1273}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_s_x1276}{S\+X1276}} \\*Derived class for S\+X1276 modules. Overrides some methods from \mbox{\hyperlink{class_s_x1278}{S\+X1278}} due to different parameter ranges }{\pageref{class_s_x1276}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_s_x1277}{S\+X1277}} \\*Derived class for S\+X1277 modules. Overrides some methods from \mbox{\hyperlink{class_s_x1278}{S\+X1278}} due to different parameter ranges }{\pageref{class_s_x1277}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_s_x1278}{S\+X1278}} \\*Derived class for S\+X1278 modules. Also used as base class for \mbox{\hyperlink{class_s_x1276}{S\+X1276}}, \mbox{\hyperlink{class_s_x1277}{S\+X1277}}, \mbox{\hyperlink{class_s_x1279}{S\+X1279}}, \mbox{\hyperlink{class_r_f_m95}{R\+F\+M95}} and \mbox{\hyperlink{class_r_f_m96}{R\+F\+M96}}. All of these modules use the same basic hardware and only differ in parameter ranges (and names) }{\pageref{class_s_x1278}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_s_x1279}{S\+X1279}} \\*Derived class for S\+X1279 modules. Overrides some methods from \mbox{\hyperlink{class_s_x1278}{S\+X1278}} due to different parameter ranges }{\pageref{class_s_x1279}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_s_x127x}{S\+X127x}} \\*Base class for \mbox{\hyperlink{class_s_x127x}{S\+X127x}} series. All derived classes for \mbox{\hyperlink{class_s_x127x}{S\+X127x}} (e.\+g. \mbox{\hyperlink{class_s_x1278}{S\+X1278}} or \mbox{\hyperlink{class_s_x1272}{S\+X1272}}) inherit from this base class. This class should not be instantiated directly from Arduino sketch, only from its derived classes }{\pageref{class_s_x127x}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_transport_layer}{Transport\+Layer}} \\*Provides common interface for protocols that run on modules with Internet connectivity, such as H\+T\+TP or M\+Q\+TT. Because this class is used mainly as interface, all of its virtual members must be implemented in the module class }{\pageref{class_transport_layer}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_x_bee}{X\+Bee}} \\*Control class for X\+Bee modules }{\pageref{class_x_bee}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_x_bee_serial}{X\+Bee\+Serial}} \\*X\+Bee Serial interface. This class is used for X\+Bees in transparent mode, i.\+e. when two X\+Bees act as a \char`\"{}wireless U\+A\+R\+T\char`\"{} }{\pageref{class_x_bee_serial}}{}
\end{DoxyCompactList}
